#!/usr/bin/env node
// =============================================================================
// Configuration Generator - Base Module
// =============================================================================
// Shared utilities and main entry point for config generation.
// Loads upstream-specific config builder based on UPSTREAM env var.
// =============================================================================

const fs = require('fs');
const path = require('path');

// Activity logging
let activity;
try {
  activity = require('../lib/activity.js');
} catch (e) {
  // Activity logging not available
  activity = null;
}

const UPSTREAM = process.env.UPSTREAM || 'openclaw';
const STATE_DIR = (process.env.OPENCLAW_STATE_DIR || `/data/.${UPSTREAM}`).replace(/\/+$/, '');
const WORKSPACE_DIR = (process.env.OPENCLAW_WORKSPACE_DIR || '/data/workspace').replace(/\/+$/, '');

function parseList(value) {
    if (!value) return [];
    return value.split(',').map(s => s.trim()).filter(s => s);
}

const PROVIDER_URLS = {
    anthropic: 'https://api.anthropic.com',
    openai: 'https://api.openai.com',
    openrouter: 'https://openrouter.ai/api',
    gemini: 'https://generativelanguage.googleapis.com',
    xai: 'https://api.x.ai',
    groq: 'https://api.groq.com/openai',
    mistral: 'https://api.mistral.ai',
    cerebras: 'https://api.cerebras.ai',
    moonshot: 'https://api.moonshot.cn',
    kimi: 'https://api.moonshot.cn',
    zai: 'https://api.z.ai',
    opencode: 'https://api.opencode.ai',
    copilot: 'https://api.githubcopilot.com',
};

const PROVIDER_MODELS = {
    anthropic: [{ id: 'claude-sonnet-4-5-20250929', name: 'claude-sonnet-4-5-20250929' }],
    openai: [{ id: 'gpt-4o', name: 'gpt-4o' }],
    openrouter: [{ id: 'anthropic/claude-sonnet-4-5', name: 'anthropic/claude-sonnet-4-5' }],
    gemini: [{ id: 'gemini-2.5-pro', name: 'gemini-2.5-pro' }],
    groq: [{ id: 'llama-3.1-70b-versatile', name: 'llama-3.1-70b-versatile' }],
    cerebras: [{ id: 'llama-3.1-70b', name: 'llama-3.1-70b' }],
    kimi: [{ id: 'kimi-k2.5', name: 'kimi-k2.5' }],
    zai: [{ id: 'glm-4.7', name: 'glm-4.7' }],
    opencode: [{ id: 'kimi-k2.5', name: 'kimi-k2.5' }],
    copilot: [{ id: 'gpt-4o', name: 'gpt-4o' }],
};

function toTomlValue(value) {
    if (value === null || value === undefined) {
        return '';
    }
    if (typeof value === 'string') {
        const escaped = value.replace(/\\/g, '\\\\').replace(/"/g, '\\"');
        return `"${escaped}"`;
    }
    if (typeof value === 'number' || typeof value === 'boolean') {
        return String(value);
    }
    if (Array.isArray(value)) {
        if (value.length === 0) return '[]';
        const items = value.map(v => toTomlValue(v));
        return '[' + items.join(', ') + ']';
    }
    return '';
}

function writeTomlSection(obj, prefix, output) {
    const nestedObjects = [];
    const simpleValues = [];

    for (const [key, value] of Object.entries(obj)) {
        if (value === null || value === undefined) continue;
        if (typeof value === 'object' && !Array.isArray(value)) {
            nestedObjects.push([key, value]);
        } else {
            simpleValues.push([key, value]);
        }
    }

    if (prefix && (simpleValues.length > 0 || nestedObjects.length > 0)) {
        output.push(`[${prefix}]`);
    }

    for (const [key, value] of simpleValues) {
        const tomlValue = toTomlValue(value);
        if (tomlValue !== '') {
            output.push(`${key} = ${tomlValue}`);
        }
    }

    if (simpleValues.length > 0 && nestedObjects.length > 0) {
        output.push('');
    }

    for (const [key, value] of nestedObjects) {
        const nestedPrefix = prefix ? `${prefix}.${key}` : key;
        writeTomlSection(value, nestedPrefix, output);
    }
}

function jsonToToml(config, headerComment = 'Generated Configuration') {
    const output = [
        `# ${headerComment}`,
        '# Generated by Docker entrypoint',
        ''
    ];

    const topLevelSections = [];
    const topLevelValues = [];

    for (const [key, value] of Object.entries(config)) {
        if (value === null || value === undefined) continue;
        if (typeof value === 'object' && !Array.isArray(value)) {
            topLevelSections.push([key, value]);
        } else {
            topLevelValues.push([key, value]);
        }
    }

    for (const [key, value] of topLevelValues) {
        const tomlValue = toTomlValue(value);
        if (tomlValue !== '') {
            output.push(`${key} = ${tomlValue}`);
        }
    }

    if (topLevelValues.length > 0 && topLevelSections.length > 0) {
        output.push('');
    }

    for (const [key, value] of topLevelSections) {
        writeTomlSection(value, key, output);
        output.push('');
    }

    return output.join('\n');
}

function getConfigInfo(upstream) {
    let configFile;
    let configFormat = 'json';

    if (upstream === 'openclaw') {
        configFile = process.env.OPENCLAW_CONFIG_PATH || path.join(STATE_DIR, `${upstream}.json`);
        configFormat = 'json';
    } else if (upstream === 'ironclaw') {
        configFile = null;
        configFormat = 'none';
    } else if (upstream === 'zeroclaw') {
        const zeroclawDir = '/data/.zeroclaw';
        fs.mkdirSync(zeroclawDir, { recursive: true });
        configFile = path.join(zeroclawDir, 'config.toml');
        configFormat = 'toml';
    } else {
        const nestedDir = path.join(STATE_DIR, `.${upstream}`);
        fs.mkdirSync(nestedDir, { recursive: true });
        configFile = path.join(nestedDir, 'config.json');
        configFormat = 'json';
    }

    return { configFile, configFormat };
}

function writeConfig(config, configInfo, upstream) {
    const { configFile, configFormat } = configInfo;

    if (configFile === null) {
        console.log('[configure] No config file needed for', upstream);
        console.log('[configure] configuration complete');
        return;
    }

    // Log configuration change before writing
    if (activity) {
        try {
            // Get current config for comparison (if exists)
            let oldConfig = null;
            if (fs.existsSync(configFile)) {
                const currentContent = fs.readFileSync(configFile, 'utf8');
                oldConfig = configFormat === 'toml' ? currentContent : JSON.parse(currentContent);
            }
            
            // Log the change
            const changes = {
                config_file: configFile,
                format: configFormat,
                upstream: upstream,
            };
            
            if (oldConfig) {
                changes.previous_config_exists = true;
            }
            
            activity.logConfigChange('system', changes, 'cli');
        } catch (e) {
            // Ignore logging errors
        }
    }

    let configContent;
    let outputFormat;
    if (configFormat === 'toml') {
        const header = `${upstream.charAt(0).toUpperCase() + upstream.slice(1)} Configuration`;
        configContent = jsonToToml(config, header);
        outputFormat = 'TOML';
    } else {
        configContent = JSON.stringify(config, null, 2);
        outputFormat = 'JSON';
    }

    fs.writeFileSync(configFile, configContent, 'utf8');
    console.log(`[configure] wrote ${outputFormat} config to`, configFile);

    const backupExt = configFormat === 'toml' ? 'toml' : 'json';
    const backupFile = path.join(STATE_DIR, `${upstream}.${backupExt}.backup`);
    fs.writeFileSync(backupFile, configContent, 'utf8');

    try {
        fs.chmodSync(configFile, 0o600);
        fs.chmodSync(backupFile, 0o600);
    } catch (e) {
        // Ignore permission errors
    }
}

function main() {
    console.log('[configure] upstream:', UPSTREAM);
    console.log('[configure] state dir:', STATE_DIR);
    console.log('[configure] workspace dir:', WORKSPACE_DIR);

    fs.mkdirSync(STATE_DIR, { recursive: true });
    fs.mkdirSync(WORKSPACE_DIR, { recursive: true });

    const configInfo = getConfigInfo(UPSTREAM);
    console.log('[configure] config file:', configInfo.configFile);

    let buildConfig;
    try {
        buildConfig = require(`./configure-${UPSTREAM}.js`).buildConfig;
    } catch (e) {
        console.log(`[configure] Unknown upstream ${UPSTREAM}, using OpenClaw format`);
        buildConfig = require('./configure-openclaw.js').buildConfig;
    }

    const config = buildConfig(STATE_DIR, WORKSPACE_DIR, parseList, PROVIDER_URLS, PROVIDER_MODELS);
    writeConfig(config, configInfo, UPSTREAM);

    // Log configuration completion
    if (activity) {
        try {
            activity.logInfo('system', 'Configuration completed', {
                upstream: UPSTREAM,
                state_dir: STATE_DIR,
                workspace_dir: WORKSPACE_DIR,
                config_file: configInfo.configFile,
            }, 'cli');
        } catch (e) {
            // Ignore logging errors
        }
    }

    console.log('[configure] configuration complete');
}

module.exports = {
    parseList,
    PROVIDER_URLS,
    PROVIDER_MODELS,
    toTomlValue,
    writeTomlSection,
    jsonToToml,
    getConfigInfo,
    writeConfig,
    UPSTREAM,
    STATE_DIR,
    WORKSPACE_DIR,
};

if (require.main === module) {
    main();
}
